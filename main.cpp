// QuadPico
//
// A project mainly for me to mess around with the Pico W
// As it stands now, I have some of the GPIOs going out to a
// Kitronik Autonomous Robotics Platform for Pico board.
// Mostly I'm utilizing an ultra-sonic emitter and listener for distance sensing
// And two motor controllers on the Kitronik.
// Since the Kitronik also has 5v running through the whole thing, supplied by a battery pack,
// I'm also using that 5v rail to power an old IR sensor I had lying around which has an
// operating voltage of 4.5v to 5.5v
//
// rp2040 Pinout and reference
// This is the cpu on the rasperby pi pico w
// https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf
//
// GPIO pins are defined in myHardware.h

#include <stdio.h>
#include "pico/stdlib.h"
#include "Buggy.h"
#include "FreeRTOS.h"
#include "task.h"
#include "hardware/pwm.h"
#include "hardware/adc.h"
#include "PWMHelper.h"
#include "QuadMusic.h"
#include "myHardware.h"



//been messing with the onboard wifi, but don't need it for current tests.
//#define WIFI

#ifdef WIFI
#include "wifi.h"

void wifiTask(void *pvParameters);
#endif

void mainTask(void *pvParameters) {
    Buggy* bug = new Buggy();
    QuadMusic* music = new QuadMusic();
    
    //motor test for sanity.
    if(0)
    {
        bug->motorOn(MOTOR_L, MOTOR_BACKWARD, 100);
        sleep_ms(1000);
        bug->motorOn(MOTOR_L, MOTOR_FORWARD, 100);
        sleep_ms(1000);
        bug->motorOff(MOTOR_L);

        bug->motorOn(MOTOR_R, MOTOR_BACKWARD, 100);
        sleep_ms(1000);
        bug->motorOn(MOTOR_R, MOTOR_FORWARD, 100);
        sleep_ms(1000);
        bug->motorOff(MOTOR_R);
    }

#ifdef WIFI
    xTaskCreate(
        wifiTask,
        "Wifi Task",
        1024,
        NULL,
        3,
        NULL);
#endif

    //This is actually going to be our duty cycle for our PWM output to the buzzer pin
    int vol = 75;

    //set our buzzer gpio to pwm and initialize it
    gpio_set_function(BUZZER_PIN, GPIO_FUNC_PWM);
    pwm_config config = pwm_get_default_config();
    pwm_config_set_clkdiv(&config, 1.f);
    uint slice_num = pwm_gpio_to_slice_num(BUZZER_PIN);
    pwm_init(slice_num, &config, true);

    //Here we set the frequency and duty cycle. This is done with a helper function I pulled from
    //some examples online. Just does a bit of math.
    uint chan = pwm_gpio_to_channel(BUZZER_PIN);

    //PWMs are split into slices and channels, which is just an awkward way of having fewer
    //PWMs than there are GPIOs (since you can set any of the 30 GPIOs to PWM, but you are only allowed 16 total PWMs)
    //There are 8 slices and 2 channels per slice (total of 16)
    // https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf
    pwm_set_freq_duty(
        slice_num,          //slice num
        chan,               //channel
        0,                  //frequency
        vol);               //duty cycle

    //Setup our ADC for reading input voltage from our IR sensor as 16-bit digital
    adc_init();
    adc_gpio_init(IR_DISTANCE_PIN);

    //There are 4 ADCs, each assigned to a specific pin. We're using ADC 0.
    adc_select_input(0);

    uint16_t adc_val = 0;
    float distance = 0;
    double freq = 0;

    while (true)
    {
        adc_val = adc_read();
        distance = bug->getDistance();
        freq = (adc_val);
        freq = music->FitFreqToAcceptableFreq(freq);

        //printf("Distance: %f\nADC: %d\n", distance, adc_val);

        //set our buzzer frequency, determined by the voltage input from the IR distance sensor ADC input
        pwm_set_freq_duty(slice_num, chan, freq, vol);
        
        //wait some amount of time, determined by our ultra-sonic distance sensor.
        //This one sends digital high to the trigger emitter,
        //Then reads how long the receiver is set to digital high.
        //This is done through PIO (peripheral in/out) which is a system on the RP2040 (chip on the pico)
        //which is an interface for creating communication with custom peripherals.
        //We can see this at work in PwmIn.cpp and PwmIn.pio
        //The PwmIn.pio.h header file is autogenerated by cmake, and is setup in our CMakeLists.txt
        sleep_ms(distance * 100);

    }
}

#ifdef WIFI
void wifiTask(void *pvParameters) {
    printf("Starting wifi\n");
    startWifi();
    printf("Wifi test done\n");
}
#endif

int main() {
    stdio_init_all();

    //printf("Welcome to hell :)\n");

    //We're using FreeRTOS, almost entirely for the task system.
    xTaskCreate(
        mainTask,    // Task to be run
        "Main Task", // Name of the Task for debugging and managing its Task Handle
        1024,        // Stack depth to be allocated for use with task's stack (see docs)
        NULL,        // Arguments needed by the Task (NULL because we don't have any)
        1,           // Task Priority - Higher the number the more priority [max is (configMAX_PRIORITIES - 1) provided in FreeRTOSConfig.h]
        NULL         // Task Handle if available for managing the task
    );

    // Should start you scheduled Tasks (such as the LED_Task above)
    vTaskStartScheduler();

    while (true) {
        // We'll never hit here, as we'll move instantly to the "Main Task" and live there for the remainded of our program.
        // This is just here for sanity.
    };
}
